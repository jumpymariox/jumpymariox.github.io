<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>jumpymariox-github-page</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="## Build Setup"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><script data-n-head="ssr" src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.7.0/mermaid.min.js"></script><link rel="preload" href="/_nuxt/runtime.51e2e4f.js" as="script"><link rel="preload" href="/_nuxt/vendors/commons.aeabdbe.js" as="script"><link rel="preload" href="/_nuxt/app.636ea3c.js" as="script"><link rel="preload" href="/_nuxt/pages/blog/_slug.63ca3e9.js" as="script"><style data-vue-ssr-id="517a8dd7:0 fa7ff0ca:0 56b15182:0 156ffb76:0">code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;opacity:1;transition:width .1s,opacity .4s;background-color:#000;z-index:999999}.nuxt-progress.nuxt-progress-notransition{transition:none}.nuxt-progress-failed{background-color:red}html{font-family:"Source Sans Pro",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;font-size:16px;word-spacing:1px;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;box-sizing:border-box}body{margin:0}.blog-container[data-v-2dc983f8]{width:100vw;padding:24px 48px}</style><link rel="preload" href="/_nuxt/static/1603208778/blog/NuxtJs/payload.js" as="script">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="blog-container" data-v-2dc983f8><h3 data-v-2dc983f8>NuxtJs</h3> <hr data-v-2dc983f8> <div class="prev-next-container" data-v-2dc983f8><!----> <br> <div class="next"><a href="/blog/NuxtJs-next">
      下一篇：NuxtJs-next
    </a></div></div> <p data-v-2dc983f8>更新于: 2020年8月25日</p> <hr data-v-2dc983f8> <p data-v-2dc983f8>目录</p> <nav data-v-2dc983f8><ul data-v-2dc983f8><li data-v-2dc983f8><a href="/blog/NuxtJs#nuxtjs的基础知识" data-v-2dc983f8>NuxtJs的基础知识</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#一-nuxtjs简介" data-v-2dc983f8>一. NuxtJs简介</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#二-服务端渲染-ssr（server-side-render）" data-v-2dc983f8>二. 服务端渲染 SSR（Server Side Render）</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#三-nuxtjs的渲染模式" data-v-2dc983f8>三. NuxtJs的渲染模式</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#nuxtjs的开发知识" data-v-2dc983f8>NuxtJs的开发知识</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#一-构建目标和指令" data-v-2dc983f8>一. 构建目标和指令</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#ssr-开发" data-v-2dc983f8>SSR 开发</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#一-nuxtjs-lifecycle" data-v-2dc983f8>一. NuxtJs Lifecycle</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#二-lifecycle-hooks的调用时机" data-v-2dc983f8>二. lifecycle hooks的调用时机</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#三-nuxtjs的ssr工作机制" data-v-2dc983f8>三. NuxtJs的SSR工作机制</a></li><li data-v-2dc983f8><a href="/blog/NuxtJs#参考文章：" data-v-2dc983f8>参考文章：</a></li></ul></nav> <div class="nuxt-content" data-v-2dc983f8 data-v-2dc983f8><p data-v-2dc983f8 data-v-2dc983f8>本文将自学时将官网未明确的知识整合，建议作为官网guide补充知识食用。</p>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>目录</strong>
[TOC]</p>
<h2 id="nuxtjs的基础知识" data-v-2dc983f8 data-v-2dc983f8><a href="#nuxtjs%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>NuxtJs的基础知识</h2>
<h3 id="一-nuxtjs简介" data-v-2dc983f8 data-v-2dc983f8><a href="#%E4%B8%80-nuxtjs%E7%AE%80%E4%BB%8B" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>一. NuxtJs简介</h3>
<blockquote data-v-2dc983f8 data-v-2dc983f8>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>官网的介绍</strong>：</p>
<p data-v-2dc983f8 data-v-2dc983f8>NuxtJs 是一个简便的 Vue 框架。</p>
</blockquote>
<p data-v-2dc983f8 data-v-2dc983f8>如官网所说，NustJs是基于vue的框架，它有一个重要特性，就是可以实现ssr。</p>
<h3 id="二-服务端渲染-ssr（server-side-render）" data-v-2dc983f8 data-v-2dc983f8><a href="#%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr%EF%BC%88server-side-render%EF%BC%89" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>二. 服务端渲染 SSR（Server Side Render）</h3>
<blockquote data-v-2dc983f8 data-v-2dc983f8>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>通用的解释</strong>:</p>
<p data-v-2dc983f8 data-v-2dc983f8>指一般情况下，一个web页面的数据渲染都是由服务器端来完成。</p>
</blockquote>
<h3 id="三-nuxtjs的渲染模式" data-v-2dc983f8 data-v-2dc983f8><a href="#%E4%B8%89-nuxtjs%E7%9A%84%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>三. NuxtJs的渲染模式</h3>
<h4 id="1-单页应用程序-spa" data-v-2dc983f8 data-v-2dc983f8><a href="#1-%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-spa" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>1. 单页应用程序 (SPA)</h4>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-text" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>sequenceDiagram
浏览器->>服务器: 初次请求
服务器->>浏览器: "js"+"空html"
浏览器->>服务器: 再次请求
服务器->>浏览器: "数据"

</code></pre></div>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-text" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>graph LR
浏览器-->| 渲染: js+数据+空html | 界面
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8>浏览器首次向服务端请求的为空的html和js，浏览器执行js后向服务器再次发起请求获取数据，最终将数据渲染进html中形成界面。</p>
<p data-v-2dc983f8 data-v-2dc983f8>实际上NuxtJs的spa模式和用vue开发模式基本相同，可以认为是在vue的基础上，加上了NuxtJs的一些特性。</p>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>优点</strong></p>
<ol data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8>由js控制页面渲染，可以借助vue-router保持同一标签页内跳转路由页面而不需重复加载基础静态资源；</li>
<li data-v-2dc983f8 data-v-2dc983f8>经过事件操作后，js可以局部更新UI而不需要刷新整个页面。</li>
</ol>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>缺点</strong></p>
<ol data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8>网站请求到的html和js中不包含数据，爬虫无法执行js获取数据，对seo很不友好；</li>
</ol>
<h4 id="2-服务器端渲染（ssr）" data-v-2dc983f8 data-v-2dc983f8><a href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88ssr%EF%BC%89" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>2. 服务器端渲染（SSR）</h4>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-text" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>sequenceDiagram
浏览器->>服务器: 初次请求
服务器->>浏览器: 渲染好的html = 数据+js+空html
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8>将浏览器请求数据和渲染成html的步骤搬到服务端完成，浏览器首次请求就是渲染完成的html，对seo也是所见即所得。</p>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>优点</strong></p>
<ul data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8>对seo友好</li>
<li data-v-2dc983f8 data-v-2dc983f8>减少客户端与服务端请求，加速首屏展示。</li>
</ul>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>缺点</strong></p>
<ul data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8>服务端负担加重，服务端的性能和距离等将成为影响首屏渲染的要素；</li>
<li data-v-2dc983f8 data-v-2dc983f8>很多客户端配置需要修改适应服务端配置，比如路由；</li>
<li data-v-2dc983f8 data-v-2dc983f8>开发runtime涉及client和server，更加复杂；</li>
</ul>
<h4 id="3-生成静态站点" data-v-2dc983f8 data-v-2dc983f8><a href="#3-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>3. 生成静态站点</h4>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-text" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>sequenceDiagram
浏览器->>服务器: 初次请求
服务器->>浏览器: 提前渲染好的 静态html+js
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8>这个模式的构建成品只有静态文件，但与同样只有静态文件的spa不同，这是经过了一次服务端渲染模式产出的html和js，相关的数据在构建时会获取一次并保存在静态文件中。</p>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>优点</strong></p>
<ul data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8>不需要服务端启动任何服务，只要将静态文件放到服务器的根路径，或者修改根路径配置即可，其实就是非常原始的静态网站。</li>
<li data-v-2dc983f8 data-v-2dc983f8>对seo友好</li>
</ul>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>缺点</strong></p>
<ul data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8>数据在构建时获取，浏览网站时并未实时数据。</li>
<li data-v-2dc983f8 data-v-2dc983f8>静态资源重复。</li>
</ul>
<h2 id="nuxtjs的开发知识" data-v-2dc983f8 data-v-2dc983f8><a href="#nuxtjs%E7%9A%84%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>NuxtJs的开发知识</h2>
<h3 id="一-构建目标和指令" data-v-2dc983f8 data-v-2dc983f8><a href="#%E4%B8%80-%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87%E5%92%8C%E6%8C%87%E4%BB%A4" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>一. 构建目标和指令</h3>
<p data-v-2dc983f8 data-v-2dc983f8>需要使用对应的指令和配置，才能对应构建NuxtJs三种渲染模式，需要配置的是<code data-v-2dc983f8 data-v-2dc983f8>nuxt.config.js</code>中的<code data-v-2dc983f8 data-v-2dc983f8>target</code>和<code data-v-2dc983f8 data-v-2dc983f8>mode</code>;</p>
<h4 id="1-构建单页应用程序-spa" data-v-2dc983f8 data-v-2dc983f8><a href="#1-%E6%9E%84%E5%BB%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-spa" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>1. 构建单页应用程序 (SPA)</h4>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-js" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8><span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// nuxt.config.js</span>
<span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>{</span>
    mode<span class="token operator" data-v-2dc983f8 data-v-2dc983f8>:</span> <span class="token string" data-v-2dc983f8 data-v-2dc983f8>'spa'</span>，
    target<span class="token operator" data-v-2dc983f8 data-v-2dc983f8>:</span> <span class="token string" data-v-2dc983f8 data-v-2dc983f8>'static'</span>
<span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>}</span>
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8>只需配置mode即可，target值只能是'static'，选择'serve'在构建时会有warning。</p>
<p data-v-2dc983f8 data-v-2dc983f8>开发相关指令：</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt build</code> 编译生成<code data-v-2dc983f8 data-v-2dc983f8>.nuxt</code>文件夹，该文件夹为本地预览服务端和本地应用运行代码;</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt export</code> 根据<code data-v-2dc983f8 data-v-2dc983f8>.nuxt</code>，生成静态资源包储存在<code data-v-2dc983f8 data-v-2dc983f8>dist</code>文件夹中；</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt serve</code> 本地启动服务，部署<code data-v-2dc983f8 data-v-2dc983f8>dist</code>中的应用，即可访问该单页应用。</p>
<h4 id="2-构建服务端渲染（ssr）" data-v-2dc983f8 data-v-2dc983f8><a href="#2-%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88ssr%EF%BC%89" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>2. 构建服务端渲染（SSR）</h4>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-js" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8><span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// nuxt.config.js</span>
<span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>{</span>
    mode<span class="token operator" data-v-2dc983f8 data-v-2dc983f8>:</span> <span class="token string" data-v-2dc983f8 data-v-2dc983f8>'universal'</span><span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>,</span>
    target<span class="token operator" data-v-2dc983f8 data-v-2dc983f8>:</span> <span class="token string" data-v-2dc983f8 data-v-2dc983f8>'serve'</span>
<span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>}</span>
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8>开发相关指令：</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt build</code> 编译生成<code data-v-2dc983f8 data-v-2dc983f8>.nuxt</code>文件夹，该文件夹为服务端应用和本地应用运行代码;</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt start</code> 启动<code data-v-2dc983f8 data-v-2dc983f8>.nuxt</code>中的代码;</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt</code> 启动开发模式，该模式下会监听项目文件修改，并自动运行<code data-v-2dc983f8 data-v-2dc983f8>nuxt build && nuxt start</code>;</p>
<h4 id="3-构建服务端静态网页" data-v-2dc983f8 data-v-2dc983f8><a href="#3-%E6%9E%84%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>3. 构建服务端静态网页</h4>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-js" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8><span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// nuxt.config.js</span>
<span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>{</span>
    mode<span class="token operator" data-v-2dc983f8 data-v-2dc983f8>:</span> <span class="token string" data-v-2dc983f8 data-v-2dc983f8>'universal'</span><span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>,</span>
    target<span class="token operator" data-v-2dc983f8 data-v-2dc983f8>:</span> <span class="token string" data-v-2dc983f8 data-v-2dc983f8>'static'</span>
<span class="token punctuation" data-v-2dc983f8 data-v-2dc983f8>}</span>
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8>开发相关指令：</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt build</code> 编译生成<code data-v-2dc983f8 data-v-2dc983f8>.nuxt</code>文件夹，文件夹为本地预览服务器和客户端应用代码；</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt export</code> 生成静态网页并储存在<code data-v-2dc983f8 data-v-2dc983f8>dist</code>文件夹中；</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt serve</code> 本地启动服务，并将服务根路径路由到<code data-v-2dc983f8 data-v-2dc983f8>dist</code>中的静态网页，可访问该服务预览静态网页。</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxt generate</code> 旧接口，相当于<code data-v-2dc983f8 data-v-2dc983f8>nuxt build</code>+<code data-v-2dc983f8 data-v-2dc983f8>nuxt export</code>，生成静态网页，并储存在<code data-v-2dc983f8 data-v-2dc983f8>dist</code>文件夹中；</p>
<h2 id="ssr-开发" data-v-2dc983f8 data-v-2dc983f8><a href="#ssr-%E5%BC%80%E5%8F%91" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>SSR 开发</h2>
<h3 id="一-nuxtjs-lifecycle" data-v-2dc983f8 data-v-2dc983f8><a href="#%E4%B8%80-nuxtjs-lifecycle" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>一. NuxtJs Lifecycle</h3>
<p data-v-2dc983f8 data-v-2dc983f8>这是官网的生命周期示意图
!image(<a href="https://zh.nuxtjs.org/guides/nuxt-lifecycle.png" rel="nofollow noopener noreferrer" target="_blank" data-v-2dc983f8 data-v-2dc983f8>https://zh.nuxtjs.org/guides/nuxt-lifecycle.png</a>)</p>
<p data-v-2dc983f8 data-v-2dc983f8>在NuxtJs的生命周期中，NuxtJs Lifecycle特有的hooks有：</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>nuxtServerInit</code>: 当项目地址被首次访问时触发一次，同页面路由跳转同域名地址时不触发，用于全局数据或者客户端请求数据（比如cookie）获取，因为是最先触发的hook，特别适合校验用户登录；</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>router middleware</code>: 注册的中间件每个页面渲染前执行，可以用于处理同类页面逻辑；</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>validate</code>: 当每一个页面渲染前触发，可用于校验路由参数或者用户鉴权；</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>asyncData</code>: 当每一个页面渲染前触发，可用于页面请求数据，将获得的数据作为返回值即会合并到component.data中，用于组件渲染；</p>
<p data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>fetch</code>: 当每一个页面渲染前触发，可用于页面请求数据，一般用于将获得数据存储到前端内存数据管理的store中；</p>
<p data-v-2dc983f8 data-v-2dc983f8>但只看官网原图很难明确看出哪些hooks在哪一侧（服务端or客户端？）运行。</p>
<p data-v-2dc983f8 data-v-2dc983f8>经过我的整理流程如下：</p>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-text" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>graph LR
&&- -->服务端运行
$$- -->客户端运行
&$- -->服务端和客户端都运行

</code></pre></div>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-text" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8>graph TB
nuxtServerInit(&&-nuxtServerInit)-->RouteMiddleware
RouteMiddleware(&$-route middleware)-->validate

validate(&&-validate)-->asyncData

asyncData(&$-asyncData)-->beforeCreated/created

beforeCreated/created(&$-beforeCreated/created)-->&&-fetch

&&-fetch-->beforedMounted/mounted

beforedMounted/mounted($$-beforedMounted/mounted)-->$$-fetch

$$-fetch($$-fetch)-->other_vue_hooks($$-其他vue hooks)
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>关于fetch的特别说明：</strong></p>
<p data-v-2dc983f8 data-v-2dc983f8>该图中出现的两个fetch都是同一个hook，只是因为在服务端调用和在客户端调用的时机不同，所以出现在两个位置。</p>
<h3 id="二-lifecycle-hooks的调用时机" data-v-2dc983f8 data-v-2dc983f8><a href="#%E4%BA%8C-lifecycle-hooks%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>二. lifecycle hooks的调用时机</h3>
<p data-v-2dc983f8 data-v-2dc983f8>上面整理了lifecycle hooks的调用顺序，但是调用时机却不一定按照顺序来，因为还要考虑hooks触发的时机。</p>
<p data-v-2dc983f8 data-v-2dc983f8>hooks触发的时机一般有三种：</p>
<ol data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8>页面首次加载；</li>
<li data-v-2dc983f8 data-v-2dc983f8>路由跳转已加载页面；</li>
<li data-v-2dc983f8 data-v-2dc983f8>事件触发数据更新；</li>
</ol>
<p data-v-2dc983f8 data-v-2dc983f8>第3事件触发数据更新调用的hook为vue lifecycle的<code data-v-2dc983f8 data-v-2dc983f8>updated</code>, 并无特殊之处，在此不做讨论，这里重点看1和2；</p>
<p data-v-2dc983f8 data-v-2dc983f8>以下为不同时机打印log查看触发的hooks：</p>
<h5 id="页面首次渲染" data-v-2dc983f8 data-v-2dc983f8><a href="#%E9%A1%B5%E9%9D%A2%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>页面首次渲染</h5>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-js" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8><span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// server</span>
asyncData
beforeCreate
created
fetch

<span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// client</span>
beforeCreate
created
</code></pre></div>
<h5 id="路由跳转已加载页面" data-v-2dc983f8 data-v-2dc983f8><a href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%B7%B2%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>路由跳转已加载页面</h5>
<div class="nuxt-content-highlight" data-v-2dc983f8 data-v-2dc983f8><pre class="line-numbers language-js" data-v-2dc983f8 data-v-2dc983f8><code data-v-2dc983f8 data-v-2dc983f8><span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// server</span>
<span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// 无</span>

<span class="token comment" data-v-2dc983f8 data-v-2dc983f8>// client</span>
asyncData
beforeCreate
created
fetch
</code></pre></div>
<p data-v-2dc983f8 data-v-2dc983f8>由此可见，当路由跳转到已加载过的页面时，服务端是不工作的，请求数据和渲染的活还是前端完成。</p>
<h3 id="三-nuxtjs的ssr工作机制" data-v-2dc983f8 data-v-2dc983f8><a href="#%E4%B8%89-nuxtjs%E7%9A%84ssr%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>三. NuxtJs的SSR工作机制</h3>
<p data-v-2dc983f8 data-v-2dc983f8>不同调用时机，工作机制有所不同</p>
<p data-v-2dc983f8 data-v-2dc983f8>在<strong data-v-2dc983f8 data-v-2dc983f8>页面首次加载</strong>和<strong data-v-2dc983f8 data-v-2dc983f8>路由跳转已加载页面</strong>这两种时机，NuxtJS的工作机制并不相同，当：</p>
<ul data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>页面首次加载</strong> 时，服务器会预渲染页面并返回给前端，是标准的SSR工作模式；</li>
<li data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>路由跳转已加载页面</strong>时，页面不会重新加载，而是与vue应用相同，执行对应的hook获取数据在前端更新应用，是SPA的工作模式；</li>
</ul>
<p data-v-2dc983f8 data-v-2dc983f8><strong data-v-2dc983f8 data-v-2dc983f8>总结一下</strong></p>
<p data-v-2dc983f8 data-v-2dc983f8>NuxtJs并不会在所有的页面加载时，都使用SSR的方式在服务端预加载，对于已加载过的页面，它充分利用了vue-router实现spa的优势，使页面保持spa的局部更新应用的优势，保证渲染成本更低。</p>
<hr data-v-2dc983f8 data-v-2dc983f8>
<h2 id="参考文章：" data-v-2dc983f8 data-v-2dc983f8><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A" aria-hidden="true" tabindex="-1" data-v-2dc983f8 data-v-2dc983f8><span class="icon icon-link" data-v-2dc983f8 data-v-2dc983f8></span></a>参考文章：</h2>
<ul data-v-2dc983f8 data-v-2dc983f8>
<li data-v-2dc983f8 data-v-2dc983f8><a href="https://zh.nuxtjs.org/" rel="nofollow noopener noreferrer" target="_blank" data-v-2dc983f8 data-v-2dc983f8>NuxtJs官网</a></li>
<li data-v-2dc983f8 data-v-2dc983f8><a href="https://zh.nuxtjs.org/blog/going-full-static/" rel="nofollow noopener noreferrer" target="_blank" data-v-2dc983f8 data-v-2dc983f8>Going Full Static</a></li>
<li data-v-2dc983f8 data-v-2dc983f8><a href="https://recurse.me/posts/choosing-a-nuxt-mode.html" rel="nofollow noopener noreferrer" target="_blank" data-v-2dc983f8 data-v-2dc983f8>NuxtJS render mode</a></li>
</ul></div></div></div></div></div><script>window.__NUXT__={staticAssetsBase:"/_nuxt/static/1603208778",layout:"default",error:null,serverRendered:!0,routePath:"/blog/NuxtJs",config:{}}</script><script src="/_nuxt/runtime.51e2e4f.js" defer></script><script src="/_nuxt/pages/blog/_slug.63ca3e9.js" defer></script><script src="/_nuxt/vendors/commons.aeabdbe.js" defer></script><script src="/_nuxt/app.636ea3c.js" defer></script>
  </body>
</html>
